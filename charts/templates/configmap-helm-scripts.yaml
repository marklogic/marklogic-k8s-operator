---
{{- $replicas := .Values.replicaCount }}
{{- $releaseName := include "marklogic.fullname" . }}
{{- $namespace := .Release.Namespace }}
{{- $clusterDomain := .Values.clusterDomain }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: helm-scripts
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/managed-by: {{ .Release.Service | quote }}
    app.kubernetes.io/instance: {{ .Release.Name | quote }}
    app.kubernetes.io/version: {{ .Chart.AppVersion }}
    helm.sh/chart: "{{ .Chart.Name }}-{{ .Chart.Version }}"
  annotations:
    "helm.sh/hook": "post-install,post-upgrade"
    "helm.sh/hook-delete-policy": hook-succeeded
    "helm.sh/hook-weight": "-5"
data:
  marklogic-setup.sh: |
    #! /bin/bash
    ###############################################################
    #
    #   Copyright 2023 MarkLogic Corporation.  All Rights Reserved.
    #
    ###############################################################
    #   Group Configuration MarkLogic server
    #
    #   ex.
    #   > marklogic-setup.sh
    #
    ###############################################################

    # Values taken directy from documentation: https://docs.marklogic.com/guide/admin-api/cluster#id_10889
    N_RETRY=60
    RETRY_INTERVAL=1

    ###############################################################
    # Logging utility
    ###############################################################
    info() {
        log "Info" "$@"
    }
    error() {
        log "Error" "$1"
        local EXIT_STATUS="$2"
        if [[ ${EXIT_STATUS} == "exit" ]]
        then
            exit 1
        fi
    }
    log () {
        local LOG_LEVEL=${1}
        TIMESTAMP=$(date +"%Y-%m-%d %T.%3N")
        shift
        echo "${TIMESTAMP} ${LOG_LEVEL}: $*"
    }
    ################################################################
    # restart_check(hostname, baseline_timestamp)
    #
    # Use the timestamp service to detect a server restart, given a
    # a baseline timestamp. Use N_RETRY and RETRY_INTERVAL to tune
    # the test length. Include authentication in the curl command
    # so the function works whether or not security is initialized.
    #   $1 :  The hostname to test against
    #   $2 :  The baseline timestamp
    # Returns 0 if restart is detected, exits with an error if not.
    ################################################################
    function restart_check {
        local hostname=$1
        local old_timestamp=$2
        local retry_count
        local last_start

        info "${hostname} - waiting for MarkLogic to restart"
        
        last_start=$( \
            curl -s --anyauth \
            --user "${MARKLOGIC_ADMIN_USERNAME}":"${MARKLOGIC_ADMIN_PASSWORD}" \
            "http://${hostname}:8001/admin/v1/timestamp" \
        )
        for ((retry_count = 0; retry_count < N_RETRY; retry_count = retry_count + 1)); do
            if [ "${old_timestamp}" == "${last_start}" ] || [ -z "${last_start}" ]; then
                info "${hostname} - waiting for MarkLogic to restart: ${old_timestamp} ${last_start}"
                sleep ${RETRY_INTERVAL}
                last_start=$( \
                    curl -s --anyauth \
                    --user "${MARKLOGIC_ADMIN_USERNAME}":"${MARKLOGIC_ADMIN_PASSWORD}" \
                    "http://${hostname}:8001/admin/v1/timestamp" \
                )
            else
                info "${hostname} - MarkLogic has restarted"
                return 0
            fi
        done
        error "${hostname} - failed to restart" exit
    }
    ################################################################
    # retry_and_timeout(target_url, expected_response_code, additional_options, return_error)
    # The third argument is optional and can be used to pass additional options to curl.
    # Fourth argurment is optional, default is set to true, can be used when custom error handling is required,
    # if set to true means function will return error and exit if curl fails N_RETRY times
    # setting to false means function will return response code instead of failing and exiting.
    # Retry a curl command until it returns the expected response
    # code or fails N_RETRY times.
    # Use RETRY_INTERVAL to tune the test length.
    # Validate that response code is the same as expected response
    # code or exit with an error.
    #
    #   $1 :  The target url to test against
    #   $2 :  The expected response code
    #   $3 :  Additional options to pass to curl
    #   $4 :  Option to return error or response code in case of error   
    ################################################################
    function curl_retry_validate {
        local retry_count
        local return_error="${4:-true}"
        for ((retry_count = 0; retry_count < N_RETRY; retry_count = retry_count + 1)); do
            request="curl -m 30 -s -w '%{http_code}' $3 $1"
            response_code=$(eval "${request}")
            if [[ ${response_code} -eq $2 ]]; then
                return "${response_code}"
            fi
            sleep ${RETRY_INTERVAL}
        done
        if [[ "${return_error}" = "false" ]] ; then
            return "${response_code}"  
        fi
        error "Expected response code ${2}, got ${response_code} from ${1}." exit
    }

    ###############################################################
    # Initialisation of MarkLogic
    ###############################################################
    # Make sure username and password variables are not empty
    if [[ -z "${MARKLOGIC_ADMIN_USERNAME}" ]] || [[ -z "${MARKLOGIC_ADMIN_PASSWORD}" ]]; then
        error "MARKLOGIC_ADMIN_USERNAME and MARKLOGIC_ADMIN_PASSWORD must be set." exit
    fi

    # generate JSON payload conditionally with license details.
    if [[ -z "${LICENSE_KEY}" ]] || [[ -z "${LICENSEE}" ]]; then
        LICENSE_PAYLOAD="{}"
    else
        info "LICENSE_KEY and LICENSEE are defined, installing MarkLogic license."
        LICENSE_PAYLOAD="{\"license-key\" : \"${LICENSE_KEY}\",\"licensee\" : \"${LICENSEE}\"}"
    fi

    # sets realm conditionally based on user input
    if [[ -z "${REALM}" ]]; then
        ML_REALM="public"
    else
        info "REALM is defined, setting realm."
        ML_REALM="${REALM}"
    fi

    if [[ -z "${MARKLOGIC_WALLET_PASSWORD}" ]]; then
        MARKLOGIC_WALLET_PASSWORD_PAYLOAD=""
    else
        MARKLOGIC_WALLET_PASSWORD_PAYLOAD="wallet-password=${MARKLOGIC_WALLET_PASSWORD}"
    fi

    # This is substituted by the helm chart templating
    replica_count={{ $replicas }}

    # generate the list of hosts based on the number of replicas
    hosts=()
    for ((i = 0; i < replica_count; i = i + 1)); do
        # This is substituted from the helm chart templating
        hosts+=( "{{ $releaseName }}-${i}.{{ $releaseName }}-headless.{{ $namespace }}.svc.cluster.local" )
    done

    info "initializing and configuring MarkLogic on ${replica_count} hosts"
    info "hosts list: ${hosts[*]}"

    info "target bootstrap host: ${MARKLOGIC_BOOTSTRAP_HOST}"
    # TODO: The first thing this should do is make sure the bootstrap host that is specified can be reached

    # if ${MARKLOGIC_BOOTSTRAP_HOST} is the same as host at index 0, then it is the bootstrap cluster
    # technically, this would be true if the bootstrap host is any host in the list but assume index 0 for now
    if [ "${MARKLOGIC_BOOTSTRAP_HOST}" = "${hosts[0]}" ]; then
        info "hosts[0] is the target bootstrap host so configuring as a bootstrap cluster"
        bootstrap_cluster=true
    else
        bootstrap_cluster=false
    fi

    # keep track of the list of hosts we have initialized
    declare -A initialized

    # TODO: Add a timeout for this loop
    while [ ${#initialized[@]} -lt $replica_count ]; do
        for hostname in ${hosts[@]}; do
            if [ "${initialized[$hostname]}" != true ]; then
                info "${hostname} - checking if responding"
                # check if the host is responding 
                timestamp=$( \
                    curl -s --anyauth \
                    --user "${MARKLOGIC_ADMIN_USERNAME}":"${MARKLOGIC_ADMIN_PASSWORD}" \
                    http://${hostname}:8001/admin/v1/timestamp \
                )

                if [ -z "${timestamp}" ]; then
                    info "${hostname} - not responding yet"
                else
                    info "${hostname} - responding, calling init"
                    out="/tmp/${hostname}.out"

                    response_code=$( \
                        curl --anyauth -m 30 -s --retry 5 \
                        -w '%{http_code}' -o "${out}" \
                        -i -X POST -H "Content-type:application/json" \
                        -d "${LICENSE_PAYLOAD}" \
                        --user "${MARKLOGIC_ADMIN_USERNAME}":"${MARKLOGIC_ADMIN_PASSWORD}" \
                        http://${hostname}:8001/admin/v1/init \
                    )

                    if [ "${response_code}" = "202" ]; then
                        info "${hostname} - init called, restart triggered"
                        last_startup=$( \
                            cat "${out}" | 
                            grep "last-startup" |
                            sed 's%^.*<last-startup.*>\(.*\)</last-startup>.*$%\1%' \
                        )

                        restart_check "${hostname}" "${last_startup}"
                        info "${hostname} - restarted"
                        info "${hostname} - init complete"
                        initialized[$hostname]=true
                    elif [ "${response_code}" -eq "204" ]; then
                        info "${hostname} - init called, no restart triggered"
                        info "${hostname} - init complete"
                        initialized[$hostname]=true
                    else
                        info "${hostname} - error calling init: ${response_code}"
                        [ -f "${out}" ] && cat "${out}"
                        # what should we do here? exit with an error? what state does that leave things in?
                        # try to init again? depends on the error that we are getting
                    fi

                fi
            fi
        done

        info "hosts initialized: ${#initialized[@]}"
        [ ${#initialized[@]} -lt $replica_count ] && sleep 1
    done

    info "all hosts initialized"

    ###############################################################
    # Installing admin user and init Security DB and objects
    ###############################################################  

    # Only do this if the bootstrap host is in the statefulset we are configuring
    if [ "${bootstrap_cluster}" = true ]; then
        info "initializing as bootstrap cluster"

        # check to see if the bootstrap host is already configured
        response_code=$( \
            curl -s --anyauth \
            -w '%{http_code}' -o "/tmp/${MARKLOGIC_BOOSTRAP_HOST}.out" \
            --user "${MARKLOGIC_ADMIN_USERNAME}":"${MARKLOGIC_ADMIN_PASSWORD}" \
            http://$MARKLOGIC_BOOTSTRAP_HOST:8002/manage/v2/hosts/$MARKLOGIC_BOOTSTRAP_HOST/properties
        )

        if [ "${response_code}" = "200" ]; then
            info "${MARKLOGIC_BOOTSTRAP_HOST} - bootstrap security already initialized"
        else
            info "${MARKLOGIC_BOOTSTRAP_HOST} - initializing bootstrap security"

            # Get last restart timestamp directly before instance-admin call to verify restart after
            timestamp=$( \
                curl -s --anyauth \
                --user "${MARKLOGIC_ADMIN_USERNAME}":"${MARKLOGIC_ADMIN_PASSWORD}" \
                "http://${MARKLOGIC_BOOTSTRAP_HOST}:8001/admin/v1/timestamp" \
            )

            curl_retry_validate "http://${MARKLOGIC_BOOTSTRAP_HOST}:8001/admin/v1/instance-admin" 202 \
                "-o /dev/null \
                -X POST -H \"Content-type:application/x-www-form-urlencoded; charset=utf-8\" \
                -d \"admin-username=${MARKLOGIC_ADMIN_USERNAME}\" --data-urlencode \"admin-password=${MARKLOGIC_ADMIN_PASSWORD}\" \
                -d \"realm=${ML_REALM}\" -d \"${MARKLOGIC_WALLET_PASSWORD_PAYLOAD}\""

            restart_check "${MARKLOGIC_BOOTSTRAP_HOST}" "${timestamp}"

            info "${MARKLOGIC_BOOTSTRAP_HOST} - bootstrap security initialized"
        fi
    fi

    ###############################################################
    # Start Group configuration
    ###############################################################              

    # The group will be called "Default" for an install but the group name could be something else on an upgrade
    # How do we know what group to update?
    # Do we support changing the group name of an existing deployment?

    # For an upgrade, get the first host in the set that is not the bootstrap host and check what group it is in
    # Use that name instead of "Default"

    # if it is an install of the bootstrap cluster, the group is "Default"
    # if it is an install of a non-bootstrap cluster, the group needs to be created if it doesn't exist
    # if the group name changes, should the old group be renamed or just create the new one and join the hosts to the new one?
    #   - the new group will be created and hosts joined to it
    #   - the old group will remain in the cluster configuration
    #   - what if it's the bootstrap cluster? still create a new group and move all hosts?

    # default to update the group
    update_group=true
    current_group=${MARKLOGIC_GROUP}

    group_cfg_template='{"group-name":"%s", "xdqp-ssl-enabled":"%s"}'
    group_cfg=$(printf "$group_cfg_template" "$MARKLOGIC_GROUP" "$XDQP_SSL_ENABLED") 

    # look at hosts[0] to see if it is in a group already
    hostname=${hosts[0]}
    response_code=$( \
        curl -s --anyauth \
        -w '%{http_code}' -o "/tmp/${MARKLOGIC_BOOTSTRAP_HOST}.out" \
        --user "${MARKLOGIC_ADMIN_USERNAME}":"${MARKLOGIC_ADMIN_PASSWORD}" \
        http://${MARKLOGIC_BOOTSTRAP_HOST}:8002/manage/v2/hosts/${hostname}/properties?format=xml
    )

    # response will be 200 if the host is in the cluster
    # response will be 404 if the host is not in the cluster
    if [ "${response_code}" = "200" ]; then
        # check to see what group the host is in
        current_group=$( \
            cat "/tmp/${MARKLOGIC_BOOTSTRAP_HOST}.out" | 
            grep "group" |
            sed 's%^.*<group.*>\(.*\)</group>.*$%\1%' \
        )

        if [ "${current_group}" = "${MARKLOGIC_GROUP}" ]; then
            info "current group is the same as the target group \"${MARKLOGIC_GROUP}\""
        else
            # the specified group is not the group that the hosts are in so we need to determine if we can rename it
            # determine if the group only has the hosts for this stateful set - if so, rename the group
            info "current group \"${current_group}"\"" is different than target group \"${MARKLOGIC_GROUP}\""
            info "comparing hosts in group ${current_group}"

            # get the list of hosts in the group
            # if the group contains hosts that are not in the "inialized" list, we need to create a new group
            response_code=$( \
                curl -s --anyauth \
                -w '%{http_code}' -o "/tmp/${MARKLOGIC_BOOTSTRAP_HOST}.out" \
                --user "${MARKLOGIC_ADMIN_USERNAME}":"${MARKLOGIC_ADMIN_PASSWORD}" \
                http://${MARKLOGIC_BOOTSTRAP_HOST}:8002/manage/v2/hosts?group-id=${current_group}&format=xml
            )

            if [ "${response_code}" != "200" ]; then
                error "unexpected response when retrieving hosts in group ${current_group}: ${response_code}" exit
            fi

            group_hosts=$( \
                cat "/tmp/${MARKLOGIC_BOOTSTRAP_HOST}.out" |
                sed -n '/<list-items>/, /<\/list-items>/p' |
                grep nameref |
                sed 's/.*<nameref>\(.*\)<\/nameref>/\1/' \
            )

            for hostname in ${group_hosts}; do
                if [ "${initialized[$hostname]}" != true ]; then
                    info "host ${hostname} exists in group \"${current_group}\" but is not in the current stateful set so the group cannot be renamed"
                    update_group=false
                    break
                fi
            done

            if [ "${update_group}" = true ]; then
                info "all hosts in group \"${current_group}\" are in the current stateful set so the group can be renamed"
            fi
        fi
    elif [ "${response_code}" = "404" ]; then
        info "host ${hostname} is not in the cluster so there is no current group to check"
    else
        error "unexpected response when retrieving group for ${hostname}: ${response_code}" exit
    fi

    info "configuring group \"${current_group}\": ${group_cfg}"

    # check if the group exists already
    response_code=$( \
        curl --anyauth -m 20 -s \
        -o /dev/null -w "%{http_code}" \
        --user ${MARKLOGIC_ADMIN_USERNAME}:${MARKLOGIC_ADMIN_PASSWORD} \
        -X GET \
        http://${MARKLOGIC_BOOTSTRAP_HOST}:8002/manage/v2/groups/${current_group} \
    )

    if [[ "${response_code}" = "200" && "${update_group}" = true ]]; then
        # group exists and we know we can update it
        info "group \"${current_group}\" exists, updating: ${group_cfg}"

        response_code=$( \
            curl -m 20 -s --retry 5 --retry-all-errors --retry-max-time 60 --anyauth \
            --user ${MARKLOGIC_ADMIN_USERNAME}:${MARKLOGIC_ADMIN_PASSWORD} \
            -w '%{http_code}' \
            -X PUT \
            -H "Content-type: application/json" \
            -d "${group_cfg}" \
            http://${MARKLOGIC_BOOTSTRAP_HOST}:8002/manage/v2/groups/${current_group}/properties \
        )

        if [[ "${response_code}" = "204" ]]; then
            info "group \"${current_group}\" updated"
        elif [[ "${response_code}" = "202" ]]; then
            # Note: THIS SHOULD NOT HAPPEN WITH THE CURRENT GROUP CONFIG
            # TODO: add logic if we add properties to the group config that could trigger a restart
            info "group \"${current_group}\" updated and a restart of all hosts in the group was triggered"
        else
            info "unexpected response when updating group \"${current_group}\": ${response_code}"
            #exit 1
            # should this exit?
        fi
    else
        # create the group
        info "group \"${MARKLOGIC_GROUP}\" does not exist, creating: ${group_cfg}"

        response_code=$( \
            curl -m 20 -s --retry 5 --retry-all-errors --retry-max-time 60 --anyauth \
            --user ${MARKLOGIC_ADMIN_USERNAME}:${MARKLOGIC_ADMIN_PASSWORD} \
            -w '%{http_code}' \
            -X POST \
            -H "Content-type: application/json" \
            -d "${group_cfg}" \
            http://${MARKLOGIC_BOOTSTRAP_HOST}:8002/manage/v2/groups \
        )

        if [[ "${response_code}" = "201" ]]; then
            info "group \"${MARKLOGIC_GROUP}\" created"
        else
            info "unexpected response when creating group \"${MARKLOGIC_GROUP}\": ${response_code}"
            #exit 1
            # should this exit?
        fi

        info "configuring the App-Services app server (port 8000) for group \"${MARKLOGIC_GROUP}\""
        response_code=$( \
            curl -m 20 -s --retry 5 --retry-all-errors --retry-max-time 60 --anyauth \
            --user ${MARKLOGIC_ADMIN_USERNAME}:${MARKLOGIC_ADMIN_PASSWORD} \
            -w '%{http_code}' \
            -X POST \
            -H "Content-type: application/json" \
            -d '{
                    "server-name":"App-Services",
                    "root":"/",
                    "port":8000,
                    "modules-database":"Modules",
                    "content-database":"Documents",
                    "error-handler":"/MarkLogic/rest-api/8000-error-handler.xqy",
                    "url-rewriter":"/MarkLogic/rest-api/8000-rewriter.xml"
                }' \
            "http://${MARKLOGIC_BOOTSTRAP_HOST}:8002/manage/v2/servers?group-id=${MARKLOGIC_GROUP}&server-type=http" \
        )

        if [[ "${response_code}" = "201" ]]; then
            info "configured the App-Services app server (port 8000) for group ${MARKLOGIC_GROUP}"
        else
            error "unexpected response when creating the App-Services app server for group ${MARKLOGIC_GROUP}: ${response_code}"
            # what should we do in this case? try again? fail? this would leave the group in an unexpected configuration
            # it depands on what the error is
            # TODO: add error handling logic here
            #exit 1
        fi
    fi

    # Now join all the hosts to the group
    for hostname in ${hosts[@]}; do
        # check if the host is already in the cluster and in a group
        # if it is in the cluster already and not in the group, set the group to the desired group

        # get the host properties from the bootstrap host
        response_code=$( \
            curl -s --anyauth \
            -w '%{http_code}' -o "/tmp/${hostname}.out" \
            --user "${MARKLOGIC_ADMIN_USERNAME}":"${MARKLOGIC_ADMIN_PASSWORD}" \
            http://${MARKLOGIC_BOOTSTRAP_HOST}:8002/manage/v2/hosts/${hostname}/properties?format=xml
        )

        # response will be 200 if the host is in the cluster
        # response will be 404 if the host is not in the cluster

        if [ "$response_code" = "200" ]; then
            # check to see what group the host is in
            # we should install jq so we can easily process JSON responses
            current_group=$( \
                cat "/tmp/${hostname}.out" | 
                grep "group" |
                sed 's%^.*<group.*>\(.*\)</group>.*$%\1%' \
            )

            info "${hostname} - current group: ${current_group}"
            if [ "${current_group}" = "${MARKLOGIC_GROUP}" ]; then
                info "${hostname} - already in group ${MARKLOGIC_GROUP}, skipping move"
            else
                # set the group
                info "${hostname} - moving to group ${MARKLOGIC_GROUP}"

                host_cfg_template='{"group":"%s"}'
                host_cfg=$(printf "$host_cfg_template" "$MARKLOGIC_GROUP") 

                timestamp=$( \
                    curl -s --anyauth \
                    --user "${MARKLOGIC_ADMIN_USERNAME}":"${MARKLOGIC_ADMIN_PASSWORD}" \
                    "http://${hostname}:8001/admin/v1/timestamp" \
                )

                response_code=$( \
                    curl -m 20 -s --retry 5 --retry-all-errors --retry-max-time 60 --anyauth \
                    --user ${MARKLOGIC_ADMIN_USERNAME}:${MARKLOGIC_ADMIN_PASSWORD}  \
                    -w '%{http_code}' \
                    -X PUT \
                    -H "Content-type: application/json" \
                    -d "${host_cfg}" \
                    http://${MARKLOGIC_BOOTSTRAP_HOST}:8002/manage/v2/hosts/${hostname}/properties \
                )

                # changing the group causes a restart
                info "${hostname} - waiting for restart"
                restart_check "${hostname}" "${timestamp}"
            fi
        else
            # add to the cluster
            info "${hostname} - joining group ${MARKLOGIC_GROUP}"

            payload=\"group=${MARKLOGIC_GROUP}\"

            curl_retry_validate "http://${hostname}:8001/admin/v1/server-config" 200 \
                "--anyauth --user \"${MARKLOGIC_ADMIN_USERNAME}\":\"${MARKLOGIC_ADMIN_PASSWORD}\" \
                -o /tmp/${hostname}.xml -X GET -H \"Accept: application/xml\""

            curl_retry_validate "http://${MARKLOGIC_BOOTSTRAP_HOST}:8001/admin/v1/cluster-config" 200 \
                "--anyauth --user \"${MARKLOGIC_ADMIN_USERNAME}\":\"${MARKLOGIC_ADMIN_PASSWORD}\" \
                -X POST -d \"${payload}\" \
                --data-urlencode \"server-config@/tmp/${hostname}.xml\" \
                -H \"Content-type: application/x-www-form-urlencoded\" \
                -o /tmp/${hostname}_cluster.zip"

            timestamp=$( \
                curl -s --anyauth \
                --user "${MARKLOGIC_ADMIN_USERNAME}":"${MARKLOGIC_ADMIN_PASSWORD}" \
                "http://${hostname}:8001/admin/v1/timestamp" \
            )

            curl_retry_validate "http://${hostname}:8001/admin/v1/cluster-config" 202 \
                "-o /dev/null --anyauth --user \"${MARKLOGIC_ADMIN_USERNAME}\":\"${MARKLOGIC_ADMIN_PASSWORD}\" \
                -X POST -H \"Content-type: application/zip\" \
                --data-binary @/tmp/${hostname}_cluster.zip"

            # 202 causes restart
            info "${hostname} - restart triggered"
            restart_check "${hostname}" "${timestamp}"

            info "${hostname} - joined group ${MARKLOGIC_GROUP}"
        fi
    done

    info "cluster configuration complete"
